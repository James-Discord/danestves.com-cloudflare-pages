---
title: 'React: de PropTypes a TypeScript'
seotitle: 'React: de PropTypes a TypeScript'
publishedAt: '2021-02-03'
summary: 'Los types pueden fortalecer la developer experience, ya que cuando algo est√° mal, puede alertarnos. TypeScript nos ayudar√° con esto.'
image: '/static/images/react-de-prop-types-a-typescript/banner.jpg'
---

Si eres un desarrollador de React.js y no usas TypeScript, ¬°este art√≠culo es para ti!

## üîå Los Props son un medio de contacto

La caracter√≠stica central de React son los componentes. Nos ayuda a tener una [verdadera separaci√≥n de conceptos](https://dottedsquirrel.com/react/rethinking-soc-with-react/). Necesitamos muchos de ellos para construir una UI completa, as√≠ que tenemos que hacerlos interactuar.

La forma sencilla de mover datos de una componente a otro es a trav√©s de props:

```jsx:single-post.jsx
import React from 'react'

import Post from './Post'

export default function SinglePost({ post }) {
  return (
    <>
      <Post title={post.title} description={post.description} />
    </>
  )
}
```

Es un patr√≥n t√≠pico: un componente obtiene informaci√≥n de props, utiliza otros componentes y les proporciona props. El component `SinglePost` aqu√≠ utiliza el componente `Post`. Para proporcionar informaci√≥n desde `SinglePost` a `Post`, utilizamos props. Es un medio de comunicaci√≥n, y debe ser visto como tal por los desarrolladores.

¬øQu√© es entonces un medio de contacto perfecto? No es tanto la capacidad de conectar, sino **las caracter√≠sticas de UX que la rodean**.

Para hablar con algunos amigos, utilizo WhatsApp. Puedo enviar y recibir mensajes, por supuesto, pero ¬øcu√°les son las caracter√≠sticas que tenemos alrededor de eso? Para saber si mi mensaje ha sido le√≠do, he visto el check azul, genial. No tengo posibilidad de editar mi mensaje, no me gusta para nada (viva Telegram). ¬øQu√© pasa con los props de React? Puedes asignar un valor a un componente, vale, pero ¬øqu√© **experiencia de desarrollador** tenemos alrededor de esto? **Type check**

Los types pueden fortalecer la DX (Developer Experience), ya que cuando algo est√° mal, puede alertarnos. El uso de [prop-types](https://www.npmjs.com/package/prop-types) es la forma normal de a√±adir **type check** a nuestros props.

```jsx:post.jsx
import React from "react";
import PropTypes from "prop-types";

const Post = ({ title, description = "" }) => {
  return (
    <div className="px-6 py-2 rounded shadow-sm">
      <h2 className="text-2xl font-bold">{title}</h2>
      {description && (
        <p className="text-sm">{description}</p>
      )}
    </div>
  );
};

Post.propTypes = {
  title: PropTypes.string.isRequired,
  description: PropTypes.string
};

export default Post
```

Genial, podemos comunicarnos m√°s eficientemente, ya que podemos decidir si una prop es requerida o no, si es una cadena u otro tipo, ¬°o incluso dar una lista estricta de valores posibles! En nuestro caso, cuando queremos ver nuestro Post, y no le pasamos un t√≠tulo, esto es lo que nos dice el navegador:

<Image
  src="/static/images/react-de-prop-types-a-typescript/console-error.png"
  alt="Error de consola al no pasarle la prop title"
  width={660}
  height={58}
/>

¬°Perfecto! Buena captura PropTypes, ¬°gracias! Imag√≠nate ahora que podemos tomar esta definici√≥n de los tipos de pruebas adicionales y la comprobaci√≥n de todo nuestro c√≥digo a√∫n m√°s all√° üöÄ

## üòé TypeScript entra a la acci√≥n

La librer√≠a prop-types estaba incluida en React antes de React v15.5. El equipo de React tom√≥ la opci√≥n de extraerla del core, fiel a su ideolog√≠a de proporcionar una librer√≠a impopular, para permitir a los desarrolladores utilizar otros sistemas de tipado, como Flow o TypeScript. Esto √∫ltimo, vamos a probarlo.

Uno de los obst√°culos de entrada de TypeScript es que la herramienta tiene que ser construida y configurada antes de que puedas usarla. No es tan f√°cil como `yarn add prop-types`, sin duda. En mi opini√≥n, la mejor manera de aprender TypeScript es saltarse completamente este paso. Simplemente construye con CRA una nueva aplicaci√≥n React, ¬°y empecemos a aprender!

```bash:create-react-app.sh
yarn create react-app my-project --template typescript
```

Creado. Ahora, en nuestro componente de `<Post />`, vamos a cambiar de PropTypes a TypeScript.

```tsx:post.tsx
import * as React from "react";

interface Props {
  title: string
  description?: string
}

const Post = ({ title, description = "" }: Props): JSX.Element => {
  return (
    <div className="px-6 py-2 rounded shadow-sm">
      <h2 className="text-2xl font-bold">{title}</h2>
      {description && (
        <p className="text-sm">{description}</p>
      )}
    </div>
  );
};

export default Post
```

La magia de TypeScript es que los `type` e `interfaces` que tenemos no s√≥lo est√°n disponibles exclusivamente. Para deducir el conocimiento, tambi√©n analiza nuestro c√≥digo.

TypeScript tambi√©n viene con un peque√±o extra: puede hacerlo justo en el editor de c√≥digo cuando est√°s desarrollando. Para obtener pistas de una funci√≥n, no tienes que esperar a que se ejecuten en el navegador, como ocurr√≠a con los prop-types.

Esto es lo que muestra mi VSCode con una funci√≥n que tengo para verificar el tiempo de lectura de un texto:

<Image
  src="/static/images/react-de-prop-types-a-typescript/example-function.png"
  alt="Funci√≥n de ejemplo para demostrar como TypeScript analiza el c√≥digo"
  width={1219}
  height={727}
/>

Ahora que estamos en esto, cambiemos tambi√©n nuestro `<SinglePost />` component:

```tsx:single-post.tsx
import * as React from 'react'

import Post from './Post'

interface Props {
  post: {
    title: string
    description?: string
  }
}

export default function SinglePost({ post }: Props) {
  return (
    <>
      <Post title={post.title} description={post.description} />
    </>
  )
}
```

Pero, ¬øqu√© pasa cuando queremos recibir un string que solo puede ser `small`, `medium` o `large` por ejemplo para el tama√±o de la foto del post? Pues veamos el siguiente c√≥digo y c√≥mo actua TypeScript con la validaci√≥n:

```tsx:single-post.tsx
import * as React from 'react'

import Post from './Post'

interface Props {
  post: {
    title: string
    description?: string
    imageSize: "small" | "medium" | "large"
  }
}

export default function SinglePost({ post }: Props): JSX.Element {
  return (
    <>
      <Post title={post.title} description={post.description} />
    </>
  )
}
```

```tsx:post.tsx
import * as React from 'react'

interface Props {
  title: string
  description?: string
  imageSize: 'small' | 'medium' | 'large'
}

const Post = ({ title, description = '', imageSize }: Props): JSX.Element => {
  return (
    <div className="px-6 py-2 rounded shadow-sm">
      <h2 className="text-2xl font-bold">{title}</h2>
      {description && <p className="text-sm">{description}</p>}
      <img src="https://picsum.photos/200/300" alt={title} className={imageSize} />
    </div>
  )
}

export default Post
```

Ahora si pasamos el mouse por encima de nuestro c√≥digo donde est√° el componente `<Post />` en `single-post.tsx` veremos el siguiente error:

<Image
  src="/static/images/react-de-prop-types-a-typescript/single-post-error.png"
  alt="Error de TypeScript de una prop faltante"
  width={1004}
  height={256}
/>

Al agregar la nueva prop y abrir las comillas nos daremos cuenta que TypeScript ahora nos est√° autocompletando los size posibles que se le puede pasar y adicionalmente nos dice que debemos pasarle el prop correcto porque de otra forma no corresponde con los types que se declararon:

<Image
  src="/static/images/react-de-prop-types-a-typescript/image-size-prop-error.png"
  alt="Error de TypeScript de la prop imageSize"
  width={771}
  height={129}
/>

Asombroso, ¬øno lo crees? üòé

Y lo que es realmente genial es que TypeScript no est√° restringido a las partes props, a diferencia de PropTypes. Todo nuestro c√≥digo JavaScript, incluso lo que no est√° conectado a nuestros componentes React, puede tener alertas. Incluso lo que no est√° totalmente conectado al front-end, ya que TypeScript funciona con NodeJS de mil maravillas.

Ahora, en nuestro c√≥digo, podemos estar seguros.

<div style={{ width: 256, height: 0, paddingBottom: 256, position: 'relative' }}>
  <iframe
    src="https://giphy.com/embed/Wn74RUT0vjnoU98Hnt"
    width="100%"
    height="100%"
    style={{ position: 'absolute' }}
    frameBorder="0"
    className="giphy-embed"
    allowFullScreen
  ></iframe>
</div>
<p>
  <a href="https://giphy.com/gifs/baby-yoda-Wn74RUT0vjnoU98Hnt">via GIPHY</a>
</p>

TypeScript estar√° ah√≠ para gritarnos si hay una discrepancia en alg√∫n lugar, se√±alando el fallo que estaba delante de nuestras narices, pero que de alguna manera pasamos por alto.

## üßê Conclusiones

No voy a mentir, el camino no es f√°cil con TypeScript y a veces la curva de aprendizaje puede ser dura. Pero sin duda vale la pena, supongo (?) üòÇ

Al proponer una herramienta de c√≥digo abierto que es sensible a los avances de JavaScript, Microsoft ha hecho un gran trabajo. Este nuevo cuasi-est√°ndar ha sido acogido por el ecosistema JS, y muchas librer√≠as son compatibles con TypeScript para permitirnos hacer nuestro c√≥digo, como hicimos en nuestros ejemplos con el `JSX.Element` de React.

Fue una apuesta a mi mismo poder entrar a TypeScript hace alg√∫n tiempo, y siempre perd√≠a. ¬øAhora en 2021? Es una apuesta bastante obvia. Hoy, ¬°√∫salo! No te arrepentir√°s.

Oh y si me hab√≠a olvidado comentarte `JSX.Element` es una forma de decirle a TypeScript que lo que retorna esa funci√≥n es JSX y no necesita hacer nada m√°s, en posteriores post que ir√© sacando sobre **aprendiendo TypeScript con React** explicar√© para que sirve `FunctionalComponent` y `JSX.Element` en nuestro c√≥digo.

**- Los veo en el c√≥digo üë®‚Äçüíª**
